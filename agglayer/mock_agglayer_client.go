// Code generated by mockery. DO NOT EDIT.

package agglayer

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	mock "github.com/stretchr/testify/mock"

	types "github.com/agglayer/aggkit/agglayer/types"
)

// AgglayerClientMock is an autogenerated mock type for the AgglayerClientInterface type
type AgglayerClientMock struct {
	mock.Mock
}

type AgglayerClientMock_Expecter struct {
	mock *mock.Mock
}

func (_m *AgglayerClientMock) EXPECT() *AgglayerClientMock_Expecter {
	return &AgglayerClientMock_Expecter{mock: &_m.Mock}
}

// GetCertificateHeader provides a mock function with given fields: ctx, certificateHash
func (_m *AgglayerClientMock) GetCertificateHeader(ctx context.Context, certificateHash common.Hash) (*types.CertificateHeader, error) {
	ret := _m.Called(ctx, certificateHash)

	if len(ret) == 0 {
		panic("no return value specified for GetCertificateHeader")
	}

	var r0 *types.CertificateHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) (*types.CertificateHeader, error)); ok {
		return rf(ctx, certificateHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) *types.CertificateHeader); ok {
		r0 = rf(ctx, certificateHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CertificateHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, certificateHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgglayerClientMock_GetCertificateHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCertificateHeader'
type AgglayerClientMock_GetCertificateHeader_Call struct {
	*mock.Call
}

// GetCertificateHeader is a helper method to define mock.On call
//   - ctx context.Context
//   - certificateHash common.Hash
func (_e *AgglayerClientMock_Expecter) GetCertificateHeader(ctx interface{}, certificateHash interface{}) *AgglayerClientMock_GetCertificateHeader_Call {
	return &AgglayerClientMock_GetCertificateHeader_Call{Call: _e.mock.On("GetCertificateHeader", ctx, certificateHash)}
}

func (_c *AgglayerClientMock_GetCertificateHeader_Call) Run(run func(ctx context.Context, certificateHash common.Hash)) *AgglayerClientMock_GetCertificateHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash))
	})
	return _c
}

func (_c *AgglayerClientMock_GetCertificateHeader_Call) Return(_a0 *types.CertificateHeader, _a1 error) *AgglayerClientMock_GetCertificateHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AgglayerClientMock_GetCertificateHeader_Call) RunAndReturn(run func(context.Context, common.Hash) (*types.CertificateHeader, error)) *AgglayerClientMock_GetCertificateHeader_Call {
	_c.Call.Return(run)
	return _c
}

// GetEpochConfiguration provides a mock function with given fields: ctx
func (_m *AgglayerClientMock) GetEpochConfiguration(ctx context.Context) (*types.ClockConfiguration, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetEpochConfiguration")
	}

	var r0 *types.ClockConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.ClockConfiguration, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.ClockConfiguration); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ClockConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgglayerClientMock_GetEpochConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEpochConfiguration'
type AgglayerClientMock_GetEpochConfiguration_Call struct {
	*mock.Call
}

// GetEpochConfiguration is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AgglayerClientMock_Expecter) GetEpochConfiguration(ctx interface{}) *AgglayerClientMock_GetEpochConfiguration_Call {
	return &AgglayerClientMock_GetEpochConfiguration_Call{Call: _e.mock.On("GetEpochConfiguration", ctx)}
}

func (_c *AgglayerClientMock_GetEpochConfiguration_Call) Run(run func(ctx context.Context)) *AgglayerClientMock_GetEpochConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AgglayerClientMock_GetEpochConfiguration_Call) Return(_a0 *types.ClockConfiguration, _a1 error) *AgglayerClientMock_GetEpochConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AgglayerClientMock_GetEpochConfiguration_Call) RunAndReturn(run func(context.Context) (*types.ClockConfiguration, error)) *AgglayerClientMock_GetEpochConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestPendingCertificateHeader provides a mock function with given fields: ctx, networkID
func (_m *AgglayerClientMock) GetLatestPendingCertificateHeader(ctx context.Context, networkID uint32) (*types.CertificateHeader, error) {
	ret := _m.Called(ctx, networkID)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestPendingCertificateHeader")
	}

	var r0 *types.CertificateHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*types.CertificateHeader, error)); ok {
		return rf(ctx, networkID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *types.CertificateHeader); ok {
		r0 = rf(ctx, networkID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CertificateHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, networkID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgglayerClientMock_GetLatestPendingCertificateHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestPendingCertificateHeader'
type AgglayerClientMock_GetLatestPendingCertificateHeader_Call struct {
	*mock.Call
}

// GetLatestPendingCertificateHeader is a helper method to define mock.On call
//   - ctx context.Context
//   - networkID uint32
func (_e *AgglayerClientMock_Expecter) GetLatestPendingCertificateHeader(ctx interface{}, networkID interface{}) *AgglayerClientMock_GetLatestPendingCertificateHeader_Call {
	return &AgglayerClientMock_GetLatestPendingCertificateHeader_Call{Call: _e.mock.On("GetLatestPendingCertificateHeader", ctx, networkID)}
}

func (_c *AgglayerClientMock_GetLatestPendingCertificateHeader_Call) Run(run func(ctx context.Context, networkID uint32)) *AgglayerClientMock_GetLatestPendingCertificateHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32))
	})
	return _c
}

func (_c *AgglayerClientMock_GetLatestPendingCertificateHeader_Call) Return(_a0 *types.CertificateHeader, _a1 error) *AgglayerClientMock_GetLatestPendingCertificateHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AgglayerClientMock_GetLatestPendingCertificateHeader_Call) RunAndReturn(run func(context.Context, uint32) (*types.CertificateHeader, error)) *AgglayerClientMock_GetLatestPendingCertificateHeader_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestSettledCertificateHeader provides a mock function with given fields: ctx, networkID
func (_m *AgglayerClientMock) GetLatestSettledCertificateHeader(ctx context.Context, networkID uint32) (*types.CertificateHeader, error) {
	ret := _m.Called(ctx, networkID)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestSettledCertificateHeader")
	}

	var r0 *types.CertificateHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*types.CertificateHeader, error)); ok {
		return rf(ctx, networkID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *types.CertificateHeader); ok {
		r0 = rf(ctx, networkID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CertificateHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, networkID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgglayerClientMock_GetLatestSettledCertificateHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestSettledCertificateHeader'
type AgglayerClientMock_GetLatestSettledCertificateHeader_Call struct {
	*mock.Call
}

// GetLatestSettledCertificateHeader is a helper method to define mock.On call
//   - ctx context.Context
//   - networkID uint32
func (_e *AgglayerClientMock_Expecter) GetLatestSettledCertificateHeader(ctx interface{}, networkID interface{}) *AgglayerClientMock_GetLatestSettledCertificateHeader_Call {
	return &AgglayerClientMock_GetLatestSettledCertificateHeader_Call{Call: _e.mock.On("GetLatestSettledCertificateHeader", ctx, networkID)}
}

func (_c *AgglayerClientMock_GetLatestSettledCertificateHeader_Call) Run(run func(ctx context.Context, networkID uint32)) *AgglayerClientMock_GetLatestSettledCertificateHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32))
	})
	return _c
}

func (_c *AgglayerClientMock_GetLatestSettledCertificateHeader_Call) Return(_a0 *types.CertificateHeader, _a1 error) *AgglayerClientMock_GetLatestSettledCertificateHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AgglayerClientMock_GetLatestSettledCertificateHeader_Call) RunAndReturn(run func(context.Context, uint32) (*types.CertificateHeader, error)) *AgglayerClientMock_GetLatestSettledCertificateHeader_Call {
	_c.Call.Return(run)
	return _c
}

// SendCertificate provides a mock function with given fields: ctx, certificate
func (_m *AgglayerClientMock) SendCertificate(ctx context.Context, certificate *types.Certificate) (common.Hash, error) {
	ret := _m.Called(ctx, certificate)

	if len(ret) == 0 {
		panic("no return value specified for SendCertificate")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Certificate) (common.Hash, error)); ok {
		return rf(ctx, certificate)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Certificate) common.Hash); ok {
		r0 = rf(ctx, certificate)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Certificate) error); ok {
		r1 = rf(ctx, certificate)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgglayerClientMock_SendCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendCertificate'
type AgglayerClientMock_SendCertificate_Call struct {
	*mock.Call
}

// SendCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - certificate *types.Certificate
func (_e *AgglayerClientMock_Expecter) SendCertificate(ctx interface{}, certificate interface{}) *AgglayerClientMock_SendCertificate_Call {
	return &AgglayerClientMock_SendCertificate_Call{Call: _e.mock.On("SendCertificate", ctx, certificate)}
}

func (_c *AgglayerClientMock_SendCertificate_Call) Run(run func(ctx context.Context, certificate *types.Certificate)) *AgglayerClientMock_SendCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.Certificate))
	})
	return _c
}

func (_c *AgglayerClientMock_SendCertificate_Call) Return(_a0 common.Hash, _a1 error) *AgglayerClientMock_SendCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AgglayerClientMock_SendCertificate_Call) RunAndReturn(run func(context.Context, *types.Certificate) (common.Hash, error)) *AgglayerClientMock_SendCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// NewAgglayerClientMock creates a new instance of AgglayerClientMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAgglayerClientMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *AgglayerClientMock {
	mock := &AgglayerClientMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
